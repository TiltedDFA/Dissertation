#!/usr/bin/env python3
"""
automate.py

Automate rebuilding and running a C++ simulator under different compile-time
parameter vectors.

For each combination of parameter values:
  1. Write them into `COMPILE_TIME_VALUES.inc`
  2. ninja-build
  3. Run the simulator executable
  4. Log parameters + stdout to results.csv
"""
#
# import itertools
# import subprocess
# import csv
# import sys
#
# # === User configuration ===

# 1) The ranges of values for each compile-time parameter.
#    Example: two params: first ∈ {1,2,3}, second ∈ {10,20}

# inline constexpr double INITIAL_TEMPERATURE = 100.0;
# inline constexpr double TEMPERATURE_COOLING_RATE = 0.95;
# inline constexpr size_t BOLTZMANN_TOURNAMENT_SIZE = 3;
# inline constexpr double MUTATION_CHANCE = 0.6;
# inline constexpr size_t ELITE_COUNT = 1;
# inline constexpr size_t POPULATION_SIZE = 50;
# inline constexpr size_t RANDOM_IMMIGRATION_COUNT = 2;
# inline constexpr size_t NUMBER_OF_RUNS = 300;

#!/usr/bin/env python3
"""
automate.py

Automate rebuilding and running a C++ simulator under different compile-time
parameter settings.

For each combination of parameter values:
  1. Write them into `compile_time_values.inc` as individual constexprs.
  2. ninja-build
  3. Run the simulator executable
  4. Save stdout to a uniquely named file
  5. Log parameters + filename (or error tag) to results.csv
"""

import itertools
import subprocess
import csv
import sys
import pathlib

# === User configuration ===

# 1) The ranges of values for each compile-time parameter.
#    Example: two params: first ∈ {1,2,3}, second ∈ {10,20}
PARAM_RANGES = [
    [100.0,],      # INITIAL_TEMPERATURE
    [0.95,0.99,0.80],       # TEMPERATURE_COOLING_RATE
    [3,5,10],             # BOLTZMANN_TOURNAMENT_SIZE
    [0.1,0.5,0.9],             # MUTATION_CHANCE
    [1,],             # ELITE_COUNT
    [20,50,100],             # POPULATION_SIZE
    [2,],             # RANDOM_IMMIGRATION_COUNT
    [200,]             # NUMBER_OF_RUNS

]

# 2) Path to the header snippet that your C++ code #includes.
#    It will contain lines like:
#      constexpr static auto val_1 = 1;
#      constexpr static auto val_2 = 10;
INCLUDE_FILE = "src/Current/compile_time_values.inc"

# 3) Ninja build command
NINJA_CMD = ["ninja"]       # e.g. ["ninja", "-C", "build"]

# 4) Simulator executable (after build)
EXECUTABLE = "./Real"  # adjust if it's e.g. "./build/simulator"

# 5) CSV log file
LOG_FILE = "results.csv"

# 6) Directory to hold all the per-run output files
OUTPUT_DIR = pathlib.Path("sim_outputs")

# === End of user configuration ===

def write_include_file(values, path):
    """
    Overwrite `path` with individual constexpr definitions:
       constexpr static auto val_1 = v1;
       constexpr static auto val_2 = v2;
       …
    """
    with open(path, "w") as f:
        f.write("// Auto-generated by automate.py\n")
        for idx, v in enumerate(values, start=1):
            f.write(f"constexpr static auto SCRIPT_GENERATED_VALUE_{idx} = {v};\n")

def build_project():
    """
    Invoke Ninja to rebuild the project. Raises CalledProcessError on failure.
    """
    print("Building with:", " ".join(NINJA_CMD))
    subprocess.run(NINJA_CMD, check=True, cwd="./build")

def run_simulator():
    """
    Runs the simulator executable, capturing and returning stdout as a string.
    Raises CalledProcessError on non-zero exit.
    """
    print("Running simulator:", EXECUTABLE)
    result = subprocess.run([EXECUTABLE],
                            capture_output=True, text=True, check=True, cwd="./build")
    return result.stdout

def main():
    # Ensure output directory exists
    OUTPUT_DIR.mkdir(exist_ok=True)

    experiment_count = 0

    # Prepare CSV with header: x1, x2, …, output_file
    header = [f"x{i+1}" for i in range(len(PARAM_RANGES))] + ["output_file"]
    with open(LOG_FILE, "w", newline="") as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(header)

        # Iterate through Cartesian product of all parameter ranges
        for combo in itertools.product(*PARAM_RANGES):
            print(f"\n==> Testing combo: {combo}")

            # 1) Generate include file
            write_include_file(combo, INCLUDE_FILE)

            # 2) Build
            try:
                build_project()
            except subprocess.CalledProcessError as e:
                err_tag = "BUILD_FAILED"
                print(f"  BUILD FAILED for {combo}", file=sys.stderr)
                writer.writerow(list(combo) + [err_tag])
                continue

            # 3) Run and capture stdout
            try:
                stdout = run_simulator()
            except subprocess.CalledProcessError as e:
                err_tag = "RUN_FAILED"
                print(f"  RUN FAILED for {combo}", file=sys.stderr)
                writer.writerow(list(combo) + [err_tag])
                continue

            # 4) Write stdout to its own file
            # fname = OUTPUT_DIR / f"out_{'_'.join(map(str, combo))}.txt"
            fname = OUTPUT_DIR / f"out_{experiment_count}.txt"
            experiment_count += 1
            with open(fname, "w") as outf:
                outf.write(stdout)

            # 5) Log parameters + filename
            writer.writerow(list(combo) + [str(fname)])
            print(f"  → output saved to {fname}")

    print(f"\nAll done. Results in {LOG_FILE} and files under {OUTPUT_DIR}/")

if __name__ == "__main__":
    main()
